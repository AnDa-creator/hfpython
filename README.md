# hfpython
Hartree-Fock solver in Python with optimisations to improve convergence

  * hydrogen.py
    Solves the radial equation for Hydrogen, using a logarighmic grid of points.
    Uses the Numerov method.
    It asks the user to input the energy to solve the Schroedinger equation.
    It solves the equation with an approximation of the boundary condition at psi(0) and also
    with an approximation of the boundary condition at psi(infinity). The result is then shown as
    the two conditions merged in a point where E-V is zero.
    If the energy is incorrect, the two boundary conditions will be inconsistent and the two
    solutions will not match.
    The energies are in Hartree atomic units, on which the Hydrogen correct energy is -0.5 Hartree
    (which is -13.6 eV).

  * hydrogen_auto.py
    Same as hydrogen.py, but it does not ask for an energy input from the user.
    It guesses the energy and calcylates the difference in the two solutions at the point on which E-V == 0.
    Using the condition that the two solutions must match, it calculates a step for the energy and updates the energy,
    repeating the calculation until it converges (using the criteria that the step in energy must be smaller than some small eps value).

  * helium.py
    Same as before, but it includes a Hartree-Fock potential as well as the Coulomb potential for Z=2.
    The effective potential generated by the other electrons in Helium would contribute to this effective potential.
    It starts by solving the Helium problem as if the two electrons have no effect on each other.
    It then calculates the Hartree-Fock potential and solves the system again, iteratively.
    The new wave functions would be closer to the correct solution in each iteration.
    It calculates the ground-state energy of Helium (the correct value is ~ -79 eV) and the eigenvalues
    of the Hartree-Fock equations. The Koopmann's Theorem says that the eigenvalues of the Hartree-Fock eq.
    are an approximation to the ionisation energy, assuming the electrons "re-arrangement" is ignored.

    In practice, there is a re-arrangement and the best estimate for the ionisation energy is to calculate the ground state
    energy for Helium and for a Z=2 atom with only one electron (which is Hydrogen, with Z=2). The difference would be
    the ionisation energy for Helium. As the ground state for Hydrogen
    with Z = 1 is -13.6 eV, and it grows with Z^2 (following the Bohr model), then the Hydrogen ground state with Z=2 would
    be 4*(-13.6) = 54.4. The ionisation energy of Helium would then be 79 eV - 54.4 eV = 24.6 eV.

    See tests/solutions.txt and tests/He/*.eps for results using this code. The error obtained in the Helium first ionisation
    energy, compared to experimental data, is ~ 1.5%.
    Bransden & Joachain (Physics of atoms and molecules) quotes an error of 1.4% for Helium due to correlation effects ignored here.

    This assumes a result for the Helium atom only: that the exchange potential cancels half the Coulomb potential, by symmetry.
    This is not valid for higher Z, but the code still works for He^+ (as in this case there is only one electron and no Coulomb potential
    is calculated).
    See hf.py for something valid until Be.

  * hf.py
    Same as helium.py, but this time it calculates the exchange potential correctly, instead of assuming it cancels half the Coulomb
    potential as in helium.py.
    One can add more Orbital() classes and change the Z value to extend it to different atoms.
    It also plots different wave functions for different orbitals in different stages of the Hartree-Fock procedure.
    One down side is that it ignores the angular part of the wave function for p,d and f orbitals. Therefore, the solution is only
    expected to work (within the uncorrelated electron approximation in Hartree-Fock and the numerical precision, as well as the
    approximation that the HF eigenfunctions all have the angular dependence as in Hydrogen) up until Be. The Coulomb and
    exchange potentials would be incorrectly calculated for p, d and f orbitals.

This would be much faster in C, but it is easier to debug it in Python. It should also be easy to play with different potentials.
One could, for example, change hydrogen_auto.py to solve the harmonic oscillator, or to solve the equations in a 1D lattice (but in this
case it is probably better not to use a logarithmid Grid and that requires changing the Schr. form used).
One could also add the angular dependence in the results (they are assumed to be separable and as in Hydrogen, so there
is no calculation for them, but perhaps it would be nice to include them in the visualisation, by taking the Hydrogen results from tables).

